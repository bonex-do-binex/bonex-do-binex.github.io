<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Open World Racer â€“ Ultra</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
</style>
</head>
<body>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
import { Sky } from 'https://unpkg.com/three@0.160.0/examples/jsm/objects/Sky.js';
import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';

//////////////////////
// RENDERER
//////////////////////

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.4;
document.body.appendChild(renderer.domElement);

//////////////////////
// SCENE + CAMERA
//////////////////////

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 20000);
camera.position.set(0, 10, -30);

//////////////////////
// SKY (Physical)
//////////////////////

const sky = new Sky();
sky.scale.setScalar(10000);
scene.add(sky);

const skyUniforms = sky.material.uniforms;
skyUniforms['turbidity'].value = 10;
skyUniforms['rayleigh'].value = 2;
skyUniforms['mieCoefficient'].value = 0.005;
skyUniforms['mieDirectionalG'].value = 0.8;

const sunPos = new THREE.Vector3();
function updateSun() {
  const phi = THREE.MathUtils.degToRad(80);
  const theta = THREE.MathUtils.degToRad(180);
  sunPos.setFromSphericalCoords(1, phi, theta);
  sky.material.uniforms.sunPosition.value.copy(sunPos);
}
updateSun();

//////////////////////
// LIGHTING
//////////////////////

const sun = new THREE.DirectionalLight(0xffffff, 3);
sun.position.set(500, 800, 500);
sun.castShadow = true;
sun.shadow.mapSize.set(4096,4096);
sun.shadow.camera.near = 1;
sun.shadow.camera.far = 3000;
sun.shadow.camera.left = -400;
sun.shadow.camera.right = 400;
sun.shadow.camera.top = 400;
sun.shadow.camera.bottom = -400;
scene.add(sun);

scene.add(new THREE.AmbientLight(0xffffff, 0.6));

//////////////////////
// TERRAIN
//////////////////////

const groundGeo = new THREE.PlaneGeometry(8000,8000,300,300);
groundGeo.rotateX(-Math.PI/2);

const verts = groundGeo.attributes.position;
for(let i=0;i<verts.count;i++){
  const x = verts.getX(i);
  const z = verts.getZ(i);
  const y = Math.sin(x*0.002)*10 + Math.cos(z*0.002)*10;
  verts.setY(i,y);
}
groundGeo.computeVertexNormals();

function makeGrassTexture() {
  const c = document.createElement('canvas');
  c.width = 256; c.height = 256;
  const ctx = c.getContext('2d');
  for (let i = 0; i < 5000; i++) {
    ctx.fillStyle = `hsl(${100 + Math.random()*40}, 60%, ${30 + Math.random()*20}%)`;
    ctx.fillRect(Math.random()*256, Math.random()*256, 3, 3);
  }
  return new THREE.CanvasTexture(c);
}

const grassTex = makeGrassTexture();
grassTex.wrapS = grassTex.wrapT = THREE.RepeatWrapping;
grassTex.repeat.set(40,40);

const ground = new THREE.Mesh(
  groundGeo,
  new THREE.MeshStandardMaterial({
    map: grassTex,
    roughness: 1
  })
);
ground.receiveShadow = true;
scene.add(ground);

//////////////////////
// ROAD
//////////////////////

function makeRoadTexture(){
  const c = document.createElement('canvas');
  c.width = 512; c.height = 512;
  const ctx = c.getContext('2d');

  ctx.fillStyle="#2a2a2a";
  ctx.fillRect(0,0,512,512);

  ctx.strokeStyle="#ffffff";
  ctx.lineWidth=10;
  ctx.setLineDash([60,40]);
  ctx.beginPath();
  ctx.moveTo(256,0);
  ctx.lineTo(256,512);
  ctx.stroke();

  return new THREE.CanvasTexture(c);
}

const roadTex = makeRoadTexture();
roadTex.wrapS = roadTex.wrapT = THREE.RepeatWrapping;
roadTex.repeat.set(1,100);

const road = new THREE.Mesh(
  new THREE.PlaneGeometry(60,8000),
  new THREE.MeshStandardMaterial({
    map: roadTex,
    roughness:0.8
  })
);
road.rotation.x = -Math.PI/2;
road.position.y = 0.3;
road.receiveShadow = true;
scene.add(road);

//////////////////////
// BUILDINGS
//////////////////////

function makeWindowTexture() {
  const c = document.createElement('canvas');
  c.width = 64; c.height = 64;
  const ctx = c.getContext('2d');

  ctx.fillStyle = '#333';
  ctx.fillRect(0,0,64,64);

  for (let i = 0; i < 200; i++) {
    ctx.fillStyle = Math.random() > 0.5 ? '#ffd27f' : '#222';
    ctx.fillRect(Math.random()*64, Math.random()*64, 4, 4);
  }

  return new THREE.CanvasTexture(c);
}

const windowTex = makeWindowTexture();
windowTex.wrapS = windowTex.wrapT = THREE.RepeatWrapping;
windowTex.repeat.set(4,4);

for(let i=0;i<400;i++){
  const h = Math.random()*150+20;

  const building = new THREE.Mesh(
    new THREE.BoxGeometry(50,h,50),
    new THREE.MeshStandardMaterial({
      map: windowTex,
      emissive: 0x222222,
      emissiveIntensity: 0.7,
      roughness:0.6,
      metalness:0.3
    })
  );

  building.position.set(
    (Math.random()-0.5)*6000,
    h/2,
    (Math.random()-0.5)*6000
  );

  building.castShadow = true;
  scene.add(building);
}

//////////////////////
// CAR
//////////////////////

const car = new THREE.Group();
scene.add(car);

const body = new THREE.Mesh(
  new THREE.BoxGeometry(5,1.5,10),
  new THREE.MeshPhysicalMaterial({
    color:0xff0000,
    metalness:1,
    roughness:0.15,
    clearcoat:1,
    clearcoatRoughness:0.03,
    reflectivity:1
  })
);
body.position.y = 4;
body.castShadow = true;
car.add(body);

const glass = new THREE.Mesh(
  new THREE.BoxGeometry(3.5,1.2,4),
  new THREE.MeshPhysicalMaterial({
    color:0x111111,
    transparent:true,
    opacity:0.4,
    roughness:0.05,
    metalness:1
  })
);
glass.position.set(0,5,-1);
car.add(glass);

const wheels=[];
function wheel(x,z){
  const w = new THREE.Mesh(
    new THREE.CylinderGeometry(1.5,1.5,1.2,32),
    new THREE.MeshStandardMaterial({color:0x111111, metalness:0.4})
  );
  w.rotation.z = Math.PI/2;
  w.position.set(x,1.5,z);
  w.castShadow = true;
  car.add(w);
  wheels.push(w);
}

wheel(-2.5,4);
wheel(2.5,4);
wheel(-2.5,-4);
wheel(2.5,-4);

car.position.y = 6;

//////////////////////
// CONTROLS
//////////////////////

let speed = 0;
const keys = {};

document.addEventListener('keydown', e => keys[e.key] = true);
document.addEventListener('keyup',   e => keys[e.key] = false);

//////////////////////
// POST-PROCESSING
//////////////////////

const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));

const bloom = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  0.6, 0.9, 0.85
);
composer.addPass(bloom);

//////////////////////
// LOOP
//////////////////////

function animate(){
  requestAnimationFrame(animate);

  if(keys['w']) speed += 0.25;
  if(keys['s']) speed -= 0.25;

  speed *= 0.98;

  if(keys['a']) car.rotation.y += 0.04*(speed/10);
  if(keys['d']) car.rotation.y -= 0.04*(speed/10);

  car.translateZ(speed);

  wheels.forEach(w => w.rotation.x += speed*0.25);

  const camOffset = new THREE.Vector3(0,12,-40);
  camOffset.applyMatrix4(car.matrixWorld);
  camera.position.lerp(camOffset,0.08);
  camera.lookAt(car.position);

  composer.render();
}
animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
